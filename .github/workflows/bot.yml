name: Enhanced Multi-Purpose Bot

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
  issues:
    types: [opened, edited, closed]
  issue_comment:
    types: [created, edited]
  push:
    branches: [main]
  schedule:
    - cron: '0 0 * * *'

jobs:
  bot:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.8"]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install flake8 autopep8 pytest coverage pre-commit


      - name: Lint with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Multi-Function Bot Core
        uses: actions/github-script@v6
        with:
          script: |
            const github = require('@actions/github');
            const context = github.context;

            /**
             * Welcomes new contributors with a personalized message on their first issue or PR.
             *
             * @returns {Promise<void>}
             */
            async function welcomeNewContributor() {
              if (github.event.sender.type == 'User') {
                const isFirstContribution = async () => {
                  try{
                    const { data: pulls } = await github.rest.pulls.list({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      state: 'all',
                      creator: context.actor,
                    });

                    const { data: issues } = await github.rest.issues.listForRepo({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      state: 'all',
                      creator: context.actor,
                    });

                    return pulls.length + issues.length === 0; //æ›´å‡†ç¡®åœ°åˆ¤æ–­æ˜¯å¦æ˜¯ç¬¬ä¸€ä¸ªè´¡çŒ®
                  } catch (error) {
                    console.error("Error checking contribution history:", error);
                    return false;  // é‡åˆ°é”™è¯¯ï¼Œé»˜è®¤ä¸æ˜¯ç¬¬ä¸€æ¬¡è´¡çŒ®ï¼Œé˜²æ­¢ Action å¤±è´¥
                  }

                };

                try {
                  if (await isFirstContribution()) {
                    const message = `ğŸ‰ Welcome to the project, @${context.actor}! ğŸ‰\n\nThank you so much for your first contribution! We really appreciate you taking the time to contribute.  We will review your pull request (or issue) as soon as possible.`;

                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: context.issue.number,
                      body: message,
                    });
                  }
                } catch (error) {
                  console.error("Error welcoming new contributor:", error);
                }
              }
            }

            /**
             * Labels issues and PRs based on keywords found in their titles.
             *
             * @returns {Promise<void>}
             */
            async function labelIssuesAndPRs() {
              try {
                const title = context.payload.pull_request ? context.payload.pull_request.title : context.payload.issue.title;
                const issueNumber = context.issue.number;

                let labels = [];

                if (title && title.toLowerCase().includes('bug')) {
                  labels.push('bug');
                }

                if (title && title.toLowerCase().includes('feature')) {
                  labels.push('feature');
                }

                if (title && title.toLowerCase().includes('documentation')) {
                  labels.push('documentation');
                }

                if (labels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: labels,
                  });
                }
              } catch (error) {
                console.error("Error labeling issue/PR:", error);
              }
            }

            /**
             * Comments on a PR when it is closed (merged or not).
             *
             * @returns {Promise<void>}
             */
            async function commentWhenPRClosed() {
              try {
                if (github.event_name === 'pull_request' && context.payload.action === 'closed') {
                  const merged = context.payload.pull_request.merged;
                  const commentBody = merged ? "ğŸ‰ This PR has been successfully merged! ğŸ‰" : "This PR has been closed without merging.";

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: commentBody,
                  });
                }
              } catch (error) {
                console.error("Error commenting on PR closure:", error);
              }
            }

            /**
             * Reacts to specific comments on issues with a thumbs up emoji.
             *
             * @returns {Promise<void>}
             */
            async function reactToIssueComments() {
              try {
                if (github.event_name === 'issue_comment' && (context.payload.action === 'created' || context.payload.action === 'edited')) {
                  const commentBody = context.payload.comment.body.toLowerCase();
                  const commentId = context.payload.comment.id;

                  if (commentBody.includes('good job') || commentBody.includes('nice work')) {
                    // React with a thumbs up
                    await github.rest.reactions.createForIssueComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: commentId,
                      content: '+1', // Thumbs up
                    });
                  }
                }
              } catch (error) {
                console.error("Error reacting to issue comment:", error);
              }
            }

            try {
              if (github.event_name === 'pull_request' || github.event_name === 'issues') {
                await welcomeNewContributor();
                await labelIssuesAndPRs();

                if (github.event_name === 'pull_request' && context.payload.action === 'closed') {
                  await commentWhenPRClosed();
                }
              }
              if (github.event_name === 'issue_comment') {
                await reactToIssueComments();
              }
            } catch (error) {
              console.error("Error during bot execution:", error);
              throw error; // Re-throw the error to fail the action
            }

      - name: Test with pytest
        run: |
          pytest tests/

      - name: Generate Coverage Report
        run: |
          coverage run -m pytest tests/
          coverage xml

      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: true
          verbose: true

      - name: Close Inactive Issues (Scheduled)
        if: github.event_name == 'schedule'
        uses: actions/github-script@v6
        with:
          script: |
            const github = require('@actions/github');
            const context = github.context;

            const DAYS_BEFORE_CLOSE = 30;

            async function getInactiveIssues() {
              try {
                const { data: issues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  sort: 'updated',
                  direction: 'asc',
                  per_page: 100,
                });

                const now = new Date();
                const inactiveIssues = issues.filter(issue => {
                  const updatedAt = new Date(issue.updated_at);
                  const diff = now.getTime() - updatedAt.getTime();
                  const days = Math.ceil(diff / (1000 * 3600 * 24));
                  return days >= DAYS_BEFORE_CLOSE && !issue.pull_request;
                });
                return inactiveIssues;
              } catch (error) {
                console.error("Error listing issues:", error);
                return []; // å‘ç”Ÿé”™è¯¯æ—¶è¿”å›ç©ºæ•°ç»„ï¼Œé¿å… Action å¤±è´¥
              }
            }

            async function closeIssue(issue) {
              const issueNumber = issue.number;
              try {
                const message = `This issue has been automatically closed due to inactivity.`;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: message,
                });

                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed',
                  reason: 'not_planned',
                });
                console.log(`Closed issue #${issueNumber}`);
              } catch (error) {
                console.error(`Error closing issue #${issueNumber}:`, error);
              }
            }

            async function main() {
              const inactiveIssues = await getInactiveIssues();

              if (inactiveIssues.length > 0) {
                for (const issue of inactiveIssues) {
                  await closeIssue(issue);
                }
              } else {
                console.log('No inactive issues found.');
              }
            }

            await main();