name: Enhanced Multi-Purpose Bot

on:
  pull_request:
    types: [opened, synchronize, reopened, closed] # PR æ‰“å¼€ï¼ŒåŒæ­¥ï¼Œé‡æ–°æ‰“å¼€, å…³é—­
  issues:
    types: [opened, edited, closed]   # Issue æ‰“å¼€ï¼Œç¼–è¾‘, å…³é—­
  issue_comment:  # å½“åœ¨ issue æˆ– PR ä¸Šæ·»åŠ è¯„è®ºæ—¶è§¦å‘
    types: [created, edited]
  push: # æ·»åŠ  push äº‹ä»¶ï¼Œç¡®ä¿ CI åŠŸèƒ½ä¹Ÿè¿è¡Œ
    branches: [ main ]
  schedule:
    - cron: '0 0 * * *'  # æ¯å¤©åˆå¤œè¿è¡Œ (ç”¨äºŽå…³é—­ä¸æ´»è·ƒçš„ Issue)

jobs:
  bot:
    runs-on: ubuntu-latest
    strategy: # æ·»åŠ  matrix ç­–ç•¥ä»¥æ”¯æŒå¤š Python ç‰ˆæœ¬æµ‹è¯•
      matrix:
        python-version: ["3.8", "3.9", "3.10", "3.11"]
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install flake8 autopep8 pytest  # å®‰è£… flake8 å’Œ autopep8

      - name: Lint with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Run Autopep8 and Create Changes
        if: github.event_name == 'pull_request' # ä»…åœ¨ pull_request æ—¶è¿è¡Œ
        run: |
          autopep8 --in-place --recursive --aggressive --aggressive .
          git diff --exit-code || echo "Code style issues found, creating a patch"
          git diff > changes.patch || echo "No style changes to apply"

      - name: Apply changes (if any)
        if: github.event_name == 'pull_request'
        run: |
          if [ -s changes.patch ]; then
            # å°†æ›´æ”¹æäº¤åˆ° PR
            git config --global user.name 'GitHub Actions Bot'
            git config --global user.email 'actions@github.com'
            git apply changes.patch
            git add .
            git commit -m "Automated PEP8 formatting"

            # æŽ¨é€åˆ° PR åˆ†æ”¯
            git remote set-url origin https://${GITHUB_ACTOR}:${{ secrets.GITHUB_TOKEN }}@github.com/${GITHUB_REPOSITORY}
            git push origin HEAD:${GITHUB_HEAD_REF}
          else
            echo "No changes to apply."
          fi

      - name: Multi-Function Bot Core
        uses: actions/github-script@v6
        with:
          script: |
            const github = require('@actions/github');
            const context = github.context;

            // === Welcome New Contributor ===
            async function welcomeNewContributor() {
              if (github.event.sender.type == 'User') {
                const isFirstContribution = async () => {
                  const { data: pulls } = await github.rest.pulls.list({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'all',
                    creator: context.actor,  // è´¡çŒ®è€…
                  });

                  const { data: issues } = await github.rest.issues.listForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'all',
                    creator: context.actor,
                  });

                  return pulls.length <= 1 && issues.length <= 1; // å¦‚æžœè¿™æ˜¯ç¬¬ä¸€ä¸ª issue æˆ– pr
                };

                if (await isFirstContribution()) {
                  const message = `
                    ðŸŽ‰ Welcome to the project, @${context.actor}! ðŸŽ‰

                    Thank you so much for your first contribution! We really appreciate you taking the time to contribute.
                    We will review your pull request (or issue) as soon as possible.
                  `;

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: message,
                  });
                }
              }
            }

            // === Label Issues/PRs ===
            async function labelIssuesAndPRs() {
                const title = context.payload.pull_request ? context.payload.pull_request.title : context.payload.issue.title;
                const issueNumber = context.issue.number;

                let labels = [];

                if (title && title.toLowerCase().includes('bug')) {
                  labels.push('bug');
                }

                if (title && title.toLowerCase().includes('feature')) {
                  labels.push('feature');
                }

                if (title && title.toLowerCase().includes('documentation')) {
                  labels.push('documentation');
                }

                if (labels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: labels,
                  });
                }
            }

            // === Comment when PR is closed ===
            async function commentWhenPRClosed() {
               if (github.event_name === 'pull_request' && context.payload.action === 'closed') {
                const merged = context.payload.pull_request.merged;
                const commentBody = merged ? "ðŸŽ‰ This PR has been successfully merged! ðŸŽ‰" : "This PR has been closed without merging.";

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody,
                });
              }
            }

            // === React to specific issue comments ===
            async function reactToIssueComments() {
                if (github.event_name === 'issue_comment' && context.payload.action === 'created' || context.payload.action === 'edited') {
                    const commentBody = context.payload.comment.body.toLowerCase();
                    const commentId = context.payload.comment.id;

                    if (commentBody.includes('good job') || commentBody.includes('nice work')) {
                      // React with a thumbs up
                      await github.rest.reactions.createForIssueComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        comment_id: commentId,
                        content: '+1', // Thumbs up
                      });
                    }
                }
            }

             // === Run the functions ===
            if (github.event_name === 'pull_request' || github.event_name === 'issues') {
              await welcomeNewContributor();
              await labelIssuesAndPRs();

              if (github.event_name === 'pull_request' && context.payload.action === 'closed') {
                await commentWhenPRClosed();
              }
            }
            if (github.event_name === 'issue_comment') {
                await reactToIssueComments();
            }
      - name: Test with pytest
        run: |
          pytest tests/ # è¿è¡Œ tests/ ç›®å½•ä¸‹çš„æµ‹è¯•
      - name: Close Inactive Issues (Scheduled)
        if: github.event_name == 'schedule' # ä»…åœ¨ schedule äº‹ä»¶è§¦å‘æ—¶è¿è¡Œ
        uses: actions/github-script@v6
        with:
          script: |
            const github = require('@actions/github');
            const context = github.context;

            const DAYS_BEFORE_CLOSE = 30; // ä¸æ´»è·ƒå¤šå°‘å¤©åŽå…³é—­

            const getInactiveIssues = async () => {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                sort: 'updated',
                direction: 'asc',  # æœ€æ—©æ›´æ–°çš„
                per_page: 100,
              });

              const now = new Date();
              const inactiveIssues = issues.filter(issue => {
                const updatedAt = new Date(issue.updated_at);
                const diff = now.getTime() - updatedAt.getTime();
                const days = Math.ceil(diff / (1000 * 3600 * 24));
                return days >= DAYS_BEFORE_CLOSE && !issue.pull_request; // ä»… issueï¼Œä¸åŒ…æ‹¬ PR
              });
              return inactiveIssues;
            };

            const inactiveIssues = await getInactiveIssues();

            if (inactiveIssues.length > 0) {
              for (const issue of inactiveIssues) {
                const issueNumber = issue.number;
                const message = `This issue has been automatically closed due to inactivity.`;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: message,
                });

                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed',
                  reason: 'not_planned', // or 'completed' if appropriate
                });
                console.log(`Closed issue #${issueNumber}`);
              }
            } else {
              console.log('No inactive issues found.');
            }